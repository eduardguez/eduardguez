<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on @eduardgz</title>
        <link>https://eduardguez.github.io/posts/</link>
        <description>Recent content in Posts on @eduardgz</description>
        <generator>Hugo -- gohugo.io</generator>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Sun, 26 Apr 2020 14:07:58 -0500</lastBuildDate>
        <atom:link href="https://eduardguez.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Aprendiendo Rust: B√°sico</title>
            <link>https://eduardguez.github.io/posts/2020/04/aprendiendo-rust-b%C3%A1sico/</link>
            <pubDate>Sun, 26 Apr 2020 14:07:58 -0500</pubDate>
            
            <guid>https://eduardguez.github.io/posts/2020/04/aprendiendo-rust-b%C3%A1sico/</guid>
            <description>¬øQu√© es Rust? Rust es un lenguaje de programaci√≥n de sistemas creado originalmente por Graydon Hoare y actualmente patrocinado por Mozilla Research. Es un lenguaje de programaci√≥n que le ayuda escribir software m√°s r√°pido y confiable. Al equilibrar la capacidad t√©cnica de gran alcance y una gran experiencia de desarrollo, sin asumir el riesgo habitual de fallas o agujeros de seguridad. Mejor a√∫n, est√° dise√±ado para guiarlo naturalmente hacia un c√≥digo eficiente en t√©rminos de velocidad y el uso de memoria.</description>
            <content type="html"><![CDATA[<h2 id="qu√©-es-rust">¬øQu√© es Rust?</h2>
<p><strong>Rust</strong> es un lenguaje de programaci√≥n de sistemas creado originalmente por <strong>Graydon Hoare</strong> y actualmente patrocinado por <strong>Mozilla Research</strong>.
Es un lenguaje de programaci√≥n que le ayuda escribir software m√°s r√°pido y confiable. Al equilibrar la capacidad t√©cnica
de gran alcance y una gran experiencia de desarrollo, sin asumir el riesgo habitual de fallas o agujeros de seguridad.
Mejor a√∫n, est√° dise√±ado para guiarlo naturalmente hacia un c√≥digo eficiente en t√©rminos de velocidad y el uso de memoria.</p>
<blockquote>
<p><strong>&ldquo;Rust es un lenguaje de programaci√≥n de sistemas centrado en tres objetivos: seguridad, velocidad y concurrencia&rdquo;.</strong>
‚Äî Documentaci√≥n de Rust.</p>
</blockquote>
<p>Es un lenguaje de programaci√≥n compilado, de c√≥digo abierto, multi-paradigm√°tico, que admite procedimientos imperativos, actores concurrentes, estilos funcionales puros y orientado a objetos.
Tambi√©n admite programaci√≥n gen√©rica y metaprogramaci√≥n, tanto en estilos est√°ticos como din√°micos.</p>
<p><img src="https://www.rust-lang.org/static/images/rust-logo-blk.svg" alt="Rust logo"></p>
<h2 id="qui√©n-est√°-usando-rust">¬øQui√©n est√° usando Rust?</h2>
<p>Hoy empresas grandes y peque√±as est√°n utilizando Rust en producci√≥n en todo el mundo, incluidos: Mozilla, Coursera, Dropbox, npm, Atlassian, Postmates y otros.
Da un vistazo a la siguiente <a href="https://www.rust-lang.org/production/users">lista de usuarios actuales</a>.</p>
<p>Est√° siendo utilizado para el desarrollo de motores de juegos, sistemas operativos, sistemas de archivos, componentes de navegador y motores de simulaci√≥n para realidad virtual.</p>
<p>Stack Overflow coloca a Rust como uno de los <a href="https://insights.stackoverflow.com/survey/2020/#technology-most-loved-dreaded-and-wanted-languages-loved">lenguajes de programaci√≥n m√°s queridos</a>
por la comunidad por cuatro a√±os consecutivos, seguido de cerca por Python.</p>
<h2 id="c√≥mo-se-involucra-mozilla-con-rust">¬øC√≥mo se involucra Mozilla con Rust?</h2>
<p>Rust est√° siendo desarrollado y patrocinado por <strong>Mozilla</strong> desde el a√±o 2009. Su primer versi√≥n estable, Rust 1.0, se presento el 15 de mayo de 2015. Actualmente Mozilla
involucra Rust en su proyecto <a href="https://servo.org/">Servo</a>, que es un motor de navegador moderno y de alto redimiendo.</p>
<hr>
<h2 id="instalar-rust">Instalar Rust</h2>
<p>Las instrucciones de instalaci√≥n para cada sistema operativo pueden ser encontradas en
<a href="https://www.rust-lang.org">rust-lang.org</a> en la gu√≠a <a href="https://www.rust-lang.org/tools/install">Installing Rust</a>.</p>
<p>Si est√° utilizando Linux o macOS, abra la terminal e ingrese el siguiente comando:</p>
<pre><code>$ curl https://sh.rustup.rs -sSf | sh
</code></pre><p>El comando anterior descarga <code>rustup</code> (instalador para Rust), que incluye el compilador <code>rustc</code> y <code>cargo</code> (administrador de paquetes).</p>
<p>Despu√©s de que Rust haya sido instalado, puede confirmar la versi√≥n instalada f√°cilmente:</p>
<pre><code>$ rustc --version
rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre><p>Si ve est√° informaci√≥n a instalado Rust con √©xito.</p>
<p>Si lo que desea es obtener la √∫ltima versi√≥n de Rust, ejecute el siguiente comando:</p>
<pre><code>$ rustup update
</code></pre><hr>
<h2 id="hola-mundo">Hola, Mundo!</h2>
<p>Este es el c√≥digo fuente del programa tradicional &ldquo;Hello World&rdquo; en Rust.</p>
<pre><code>fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre><p>A continuaci√≥n, cree un archivo <code>main.rs</code> para almacenar su c√≥digo Rust e ingrese el siguiente comando en la terminal (desde la ruta donde fue
guardado el archivo) para compilar su programa:</p>
<pre><code>$ rustc main.rs
</code></pre><p>Despu√©s de compilar con √©xito, Rust genera un ejecutable binario <code>main</code> similar a C o C++. Para ejecutar su programa ingrese el siguiente comando:</p>
<pre><code>$ ./main
</code></pre><p>Independientemente de su sistema operativo la cadena <code>Hello World!</code> debe imprimirse.</p>
<p>Tambi√©n puede utilizar <a href="https://play.rust-lang.org/">Rust Playground</a>, una interfaz web para ejecutar c√≥digo de Rust.</p>
<hr>
<h2 id="sintaxis">Sintaxis</h2>
<p>La funci√≥n <code>main</code> es el primer c√≥digo que se ejecuta en cada programa ejecutable de Rust. Adem√°s, el cuerpo de la funci√≥n
se envuelve entre llaves <code>{}</code> y se terminan todas las expresiones con punto y coma <code>;</code>.</p>
<pre><code>fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre><p><code>println!</code> es una macro de Rust para imprimir texto. Una macro se distingue de una funci√≥n por llevar un signo de admiraci√≥n <code>!</code>.</p>
<hr>
<h2 id="hola-cargo">Hola, Cargo!</h2>
<p><strong>Cargo</strong> es el sistema de construcci√≥n y administrador de paquetes de Rust.</p>
<p>A medida que escriba programas con Rust m√°s complejos, Cargo manejara muchas tareas por usted en el mundo real, como construir
su c√≥digo, descargar las bibliotecas de las que depende su c√≥digo, compilar paquetes, hacer paquetes distribuibles
y cargarlos en <a href="https://crates.io/">creates.io</a> para compartir su c√≥digo con otras personas.</p>
<p>Para lograr este objetivo, Cargo hace cuatro cosas:</p>
<ul>
<li>Introduce dos archivos de metadatos con varios bits de informaci√≥n del paquete.</li>
<li>Obtiene y construye las dependencias de su paquete.</li>
<li>Invoca <code>rustc</code> u otra herramienta de compilaci√≥n con los par√°metros correctos para compilar su paquete.</li>
<li>Introduce convenciones para facilitar el trabajo con paquetes Rust.</li>
</ul>
<p>Verifique si Cargo est√° instalado ingresando lo siguiente en su terminal:</p>
<pre><code>$ cargo --version
</code></pre><p>Para comenzar un proyecto usando Cargo en cualquier sistema operativo, ejecute lo siguiente:</p>
<pre><code>$ cargo new hello_cargo
$ cd hello_cargo
$ ls -F
</code></pre><p>Cargo ha generado dos archivos y un directorio por nosotros:</p>
<pre><code>‚îú‚îÄ‚îÄ src
‚îÇ   ‚îî‚îÄ‚îÄ main.rs
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
</code></pre><ul>
<li><strong>Cargo.toml</strong>: Archivo de <strong>manifiesto</strong> que contiene todos los metadatos que Cargo necesita para compilar su paquete.</li>
<li><strong>Cargo.lock</strong>: Archivo que realiza un seguimiento de las versiones exactas de las dependencias en su paquete.</li>
<li><strong>src/</strong>: Cargo aloja el c√≥digo fuente en este directorio.</li>
</ul>
<p>La estructura del archivo <code>Cargo.toml</code> es la siguiente:</p>
<pre><code>[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;
</code></pre><p>Dentro del encabezado de secci√≥n <code>[package]</code> se establece la informaci√≥n de configuraci√≥n del paquete que Cargo necesita para compilarlo.</p>
<p>Cargo est√° configurado para buscar dependencias en <a href="https://crates.io/">creates.io</a> de forma predeterminada, en la secci√≥n <code>[dependencies]</code>
se enumera todos los paquetes de c√≥digo (cajas) de su proyecto. S√≥lo el nombre y una cadena de versi√≥n son necesarios.</p>
<p>Da un vistazo a los requisitos de versi√≥n <a href="https://github.com/steveklabnik/semver#requirements">semver</a>.</p>
<pre><code>[dependencies]
time = &quot;0.1.12&quot;
</code></pre><p>Cargo proporciona los siguientes comandos para construir y ejecutar un proyecto:</p>
<ul>
<li><code>cargo build</code> Construye el proyecto y crea un archivo ejecutable.
<ul>
<li>Su ejecuci√≥n por primer vez crea un nuevo archivo <strong>Cargo.lock</strong>.</li>
</ul>
</li>
<li><code>cargo check</code> Verifica que el c√≥digo pueda ser compilado.</li>
<li><code>cargo run</code> Compila el c√≥digo y ejecuta el ejecutable resultante.</li>
</ul>
<hr>
<h2 id="comentarios">Comentarios</h2>
<p>Los comentarios no documentales en Rust siguen el estilo general de C++.</p>
<pre><code>LINE_COMMENT:
//(~ [/ !] |//) ~\n *
|//

BLOCK_COMMENT:
/*(~ [ * !] | **| BlockCommentOrDoc ) ( BlockCommentOrDoc | ~ */) * */
| /**/
</code></pre><hr>
<h2 id="variables">Variables</h2>
<p>Las definiciones de variables en Rust comienzan con la palabra clave <code>let</code> seguida del nombre de la variable y valor asignado.
Por defecto en Rust las variables son inmutables, aprovechando as√≠ la seguridad y f√°cil concurrencia.</p>
<pre><code>let any_number = 5;
</code></pre><p>Sin embargo, tiene la opci√≥n de hacer que sus variables sean mutables, agregando <code>mut</code> delante de la palabra clave <code>let</code>.</p>
<pre><code>let mut any_number = 5;
</code></pre><hr>
<h2 id="constantes">Constantes</h2>
<p>Una constante se declara usando la palabra clave <code>const</code>, y el tipo de dato debe ser especificado seguido de dos puntos <code>:</code>.</p>
<pre><code>const MAX_POINTS: u32 = 100_000;
</code></pre><p>Las constantes no solo son inmutables por defecto, siempre son inmutables.</p>
<hr>
<h2 id="est√°ticas">Est√°ticas</h2>
<p>La palabra clave <code>static</code> se √∫tiliza para definir una &ldquo;variable global&rdquo;.</p>
<pre><code>static N: i32 = 5;
</code></pre><p>Solo hay una instancia para cada valor y est√° en una ubicaci√≥n fija en la memoria.</p>
<hr>
<h2 id="sombreado">Sombreado</h2>
<p>Es posible sombrear una variable repitiendo el mismo nombre de la variable y repitiendo el uso de <code>let</code>.</p>
<pre><code>fn main() {
  let x = 5;
  let x = x + 1;
  println!(&quot;The value of x is: {}&quot;, x); // The value of x is: 6
}
</code></pre><p>Al usar la palabra clave <code>let</code>, es posible cambiar el tipo de dato y reutilizar el mismo nombre.</p>
<pre><code>let spaces = &quot;   &quot;;
let spaces = spaces.len();
</code></pre><p>Adem√°s, el sombreado nos ahorra tener que inventar nombres diferentes para cada variable.</p>
<hr>
<h2 id="operadores">Operadores</h2>
<hr>
<h3 id="operadores-aritm√©ticos">Operadores aritm√©ticos</h3>
<p>Rust admite las operaciones matem√°ticas b√°sicas que esperar√≠a en otros lenguajes de programaci√≥n: suma, resta, multiplicaci√≥n,
divisi√≥n y m√≥dulo.</p>
<pre><code>fn main() {
  // addition
  let sum = 5 + 10;

  // subtraction
  let difference = 95.5 - 4.3;

  // multiplication
  let product = 4 * 30;

  // division
  let quotient = 56.7 / 32.2;

  // remainder
  let remainder = 43 % 5;
}
</code></pre><h3 id="operadores-de-comparaci√≥n">Operadores de comparaci√≥n</h3>
<p><code>== != &lt; &gt; &lt;= &gt;=</code></p>
<pre><code>fn main() {
  let a = 1;
  let b = 2;

  let c = a == b;  // false
  let d = a != b;  // true
  let e = a &lt; b;   // true
  let f = a &gt; b;   // false
  let g = a &lt;= a;  // true
  let h = a &gt;= a;  // true
}
</code></pre><h3 id="operadores-l√≥gicos">Operadores l√≥gicos</h3>
<p><code>! &amp;&amp; ||</code></p>
<pre><code>fn main() {
  let a = true;
  let b = false;

  let c = !a;      // false
  let d = a &amp;&amp; b;  // false
  let e = a || b;  // true
}
</code></pre><h3 id="operadores-bit-a-bit">Operadores bit a bit</h3>
<p><code>&amp; | ^ &lt;&lt; &gt;&gt;</code></p>
<pre><code>fn main() {
  let a = 1;
  let b = 2;

  let c = a &amp; b;  //0  (01 &amp;&amp; 10 -&gt; 00)
  let d = a | b;  //3  (01 || 10 -&gt; 11)
  let e = a ^ b;  //3  (01 != 10 -&gt; 11)
  let f = a &lt;&lt; b; //4  (Add b number of 0s to the end of a -&gt; '01'+'00' -&gt; 100)
  let g = a &gt;&gt; b; //0  (Remove b number of bits from the end of a -&gt; oÃ∂1Ã∂ -&gt; 0)
}
</code></pre><h3 id="operadores-de-pr√©stamo">Operadores de pr√©stamo</h3>
<p>Los operadores <code>&amp;&amp;</code> o <code>&amp;mut</code> se usan al hacer referencia a una variable original; tomando prestados los datos de la misma.</p>
<pre><code>fn main() {
  let mut guess = String::new();

  io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
}
</code></pre><p>El tipo de pr√©stamo mutable, permiten tomar prestados los datos y alterar una variable, por ejemplo al leer una l√≠nea de la terminal.</p>
<hr>
<h2 id="tipos-de-datos">Tipos de datos</h2>
<hr>
<h3 id="tipos-escalares">Tipos escalares</h3>
<p>Un tipo escalar representa un valor √∫nico.</p>
<h4 id="enteros">Enteros</h4>
<p>Esta declaraci√≥n de tipo indica que cada variante puede ser firmada o no y tienen un tama√±o explicito.</p>
<p>Firmado y sin firmar se refieren a si es posible que el n√∫mero sea positivo o negativo.</p>
<table>
<thead>
<tr>
<th align="left">Longitud</th>
<th align="center">Firmado</th>
<th align="right">No firmado</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">8 bits</td>
<td align="center">i8</td>
<td align="right">u8</td>
</tr>
<tr>
<td align="left">16 bits</td>
<td align="center">i16</td>
<td align="right">u16</td>
</tr>
<tr>
<td align="left">32 bits</td>
<td align="center">i32</td>
<td align="right">u32</td>
</tr>
<tr>
<td align="left">64 bits</td>
<td align="center">i32</td>
<td align="right">u32</td>
</tr>
<tr>
<td align="left">128 bits</td>
<td align="center">i32</td>
<td align="right">u32</td>
</tr>
<tr>
<td align="left">arch</td>
<td align="center">isize</td>
<td align="right">usize</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Una variante firmada (<code>i</code>) puede almacenar n√∫meros de $-(2^{n-1})$ a $2^{n-1}-1$.</p>
</li>
<li>
<p>Una variante sin firmar (<code>u</code>) puede almacenar n√∫meros de 0 a $2^n-1$.</p>
</li>
<li>
<p><code>n</code> es el n√∫mero de bits que usa la variante.</p>
</li>
<li>
<p>Los tipos <code>isize</code> <code>usize</code> dependen de la arquitectura del computador en el que se ejecuta el programa.</p>
</li>
</ul>
<h4 id="punto-flotante">Punto flotante</h4>
<p>Los tipos de punto flotante de Rust son <code>f32</code> y <code>f64</code></p>
<pre><code>fn main() {
  let x = 2.0; // f64

  let y: f32 = 3.0; // f32
}
</code></pre><p>El tipo <code>f32</code> es un flotador de precisi√≥n simple y <code>f64</code> tiene doble precisi√≥n.</p>
<h4 id="booleanos">Booleanos</h4>
<p>Un tipo booleano en Rust tiene dos valores posibles: <code>true</code> y <code>false</code>.</p>
<pre><code>fn main() {
  let t = true;

  let f: bool = false; // with explicit type annotation
}
</code></pre><h4 id="caracteres">Caracteres</h4>
<p>El tipo <code>char</code> de Rust tiene un tama√±o de cuatro bytes y representa un valor escalar Unicode.</p>
<pre><code>fn main() {
  let c = 'z';
  let z = '‚Ñ§';
  let heart_eyed_cat = 'üòª';
}
</code></pre><hr>
<h3 id="tipos-compuestos">Tipos compuestos</h3>
<p>Los tipos compuestos pueden agrupar m√∫ltiples valores en un tipo.</p>
<h4 id="tuplas">Tuplas</h4>
<p>Una tupla es una colecci√≥n de valores de diferentes tipos de datos.</p>
<pre><code>fn main() {
  let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre><h4 id="matrices">Matrices</h4>
<p>A diferencia de una tupla, una matriz es una colecci√≥n de objetos del mismo tipo de dato.</p>
<pre><code>fn main() {
  let ex1a: [i32; 5] = [1, 2, 3, 4, 5];
  let ex1b = [1, 2, 3, 4, 5];
  let ex2a = [3; 5]; 
  let ex2b = [3, 3, 3, 3, 3];
}
</code></pre><hr>
<h2 id="funciones">Funciones</h2>
<p>Las funciones se declaran usando la palabra clave <code>fn</code>, y si devuelve un valor debe de especificarse el tipo de retorno despu√©s de una flecha <code>-&gt;</code>.</p>
<pre><code>fn plus_one(x: i32) -&gt; i32 {
  x + 1
}
</code></pre><p>Podemos devolver un valor con la instrucci√≥n <code>return</code>, incluso desde bucles internos o <code>if</code>s.</p>
<pre><code>fn main() {
  let x = plus_one(5);
  println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre><p>Adem√°s, a Rust no le importa el orden en el que define sus funciones.</p>
<hr>
<h2 id="flujos-de-control">Flujos de control</h2>
<p>Las expresiones m√°s comunes que le permiten controlar el flujo de ejecuci√≥n del c√≥digo de Rust son expresiones <code>if</code>-<code>else if</code>-<code>else</code> y bucles.</p>
<hr>
<h3 id="if--else-if--else"><code>if</code> / <code>else if</code> / <code>else</code></h3>
<p>Las expresiones <code>if</code>, <code>else if</code> y <code>else</code> le permiten bifurcar su c√≥digo seg√∫n las condiciones. A diferencia de JavaScript y Ruby,
Rust no intentar√° autom√°ticamente convertir tipos no booleanos a booleanos. Es necesario ser explicito y proporcionar a una sentencia <code>if</code>
un booleano como condici√≥n.</p>
<pre><code>fn main() {
  let number = 6;

  if number % 4 == 0 {
      println!(&quot;number is divisible by 4&quot;);
  } else if number % 3 == 0 {
      println!(&quot;number is divisible by 3&quot;);
  } else if number % 2 == 0 {
      println!(&quot;number is divisible by 2&quot;);
  } else {
      println!(&quot;number is not divisible by 4, 3, or 2&quot;);
  }
}
</code></pre><p>Rust solo ejecuta el bloque para la primera condici√≥n verdadera, el resto lo ignora.</p>
<p>Debido a que <code>if</code> es una expresi√≥n, es posible usarla en la declaraci√≥n de una variable. Sin embargo, los valores que tienen el potencial de ser resultados
en cada <code>if</code> deben de ser del mismo tipo.</p>
<pre><code>fn main() {
  let condition = true;
  let number = if condition { 5 } else { 6 };

  println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre><hr>
<h3 id="match"><code>match</code></h3>
<p>Rust proporciona coincidencia de patrones a trav√©s de la palabra clave <code>match</code>, que se puede utilizar como un <code>switch</code> en C/C++.</p>
<pre><code>fn main() {
  let mut guess = String::new();

  println!(&quot;Please input your guess.&quot;);

  io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);

  let guess: u32 = match guess.trim().parse() {
    Ok(guess) =&gt; println!(&quot;Ok!&quot;),
    Err(_) =&gt; println!(&quot;Error :c&quot;),
  };
}
</code></pre><p>Una expresi√≥n <code>match</code> est√° hecha de brazos. Un brazo consiste en un patr√≥n y el c√≥digo que debe ejecutarse si el valor dado al comienzo de la expresi√≥n <code>match</code> se ajusta al patr√≥n de ese brazo.</p>
<hr>
<h3 id="bucles">Bucles</h3>
<p>Rust proporciona varios bucles: <code>loop</code>, <code>while</code> y <code>for</code>.</p>
<hr>
<h4 id="loop"><code>loop</code></h4>
<p>La expresi√≥n <code>loop</code> denota la ejecuci√≥n de un bloque de c√≥digo una y otra vez (bucle infinito) o hasta que expl√≠citamente alcance una declaraci√≥n final.</p>
<pre><code>fn main() {
  loop {
    println!(&quot;again!&quot;);
    break;
  }
}
</code></pre><p>Cuando <code>break</code> se encuentra, la ejecuci√≥n del cuerpo del bucle infinito asociado finaliza inmediatamente, mientras que la declaraci√≥n <code>continue</code> puede usarse para omitir el resto de la iteraci√≥n
y comenzar una nueva.</p>
<pre><code>fn main() {
  let mut counter = 0;

  let result = loop {
    counter += 1;

    if counter == 3 {
      println!(&quot;Three&quot;);
      // Skip the rest of this iteration
      continue;
    }

    if counter == 10 {
      break counter * 2;
    }
  };

  println!(&quot;The result is {}&quot;, result);
}
</code></pre><p>A diferencia de los otros tipos de bucles en Rust, <code>loop</code> puede ser usado como expresesi√≥n que retorna un valor haciendo uso de <code>break</code>.</p>
<h4 id="while"><code>while</code></h4>
<p>La sintaxis del ciclo <code>while</code> es similar a la de otros lenguajes de programaci√≥n, en la que se define una condici√≥n verdadera
que delimitar√° el n√∫mero de veces que el c√≥digo se ejecuta.</p>
<pre><code>fn main() {
  let mut number = 3;

  while number != 0 {
    println!(&quot;{}!&quot;, number);
    number -= 1;
  }
  println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre><p>Esta construcci√≥n elimina una gran cantidad de anidaci√≥n que ser√≠a necesaria si se ha utilizado <code>loop</code>, <code>if</code>, <code>else</code> y/o <code>break</code>.</p>
<h4 id="for"><code>for</code></h4>
<p>Como alternativa m√°s concisa, puede usar un bucle <code>for</code> y ejecutar un c√≥digo para cada elemento de una colecci√≥n.</p>
<pre><code>fn main() {
  let a = [10, 20, 30, 40, 50];

  for element in a.iter() {
      println!(&quot;the value is: {}&quot;, element);
  }
}
</code></pre><p>La seguridad y la concisi√≥n de los bucles <code>for</code> los convierten en la construcci√≥n de bucles m√°s utilizada en Rust.</p>
<hr>
<h2 id="ejercicio-1-guessing-game">Ejercicio 1 &ldquo;Guessing Game&rdquo;</h2>
<h2 id="ejercicio-2-fizz-buzz">Ejercicio 2 &ldquo;Fizz Buzz&rdquo;</h2>
<hr>
<p>La implementaci√≥n de algunos ejemplos relacionados con el post se pueden encontrar en <a href="https://github.com/eduardguez/learning-rust">mi repositorio de Github</a>.</p>
<hr>
<h2 id="referencias">Referencias</h2>
<p>Garc√≠a, M. (2019, enero 22). Primeros pasos con Rust y porque aprenderlo. Recuperado 26 de abril de 2020, de <a href="https://dev.to/mattdark/primeros-pasos-con-rust-y-porque-aprenderlo-1oc3">https://dev.to/mattdark/primeros-pasos-con-rust-y-porque-aprenderlo-1oc3</a></p>
<p>Klabnik, S., &amp; Nichols, C. (2018). The Rust Programming Language (1st Edition ed.). San Francisco, CA: No Starch Press.</p>
<p>Madunuwan, D. (2020, abril 26). Why Rust? Recuperado 5 de mayo de 2020, de <a href="https://learning-rust.github.io/docs/a1.why_rust.html">https://learning-rust.github.io/docs/a1.why_rust.html</a></p>
<p>Rust. (2018, enero 19). Recuperado 26 de abril de 2020, de <a href="https://research.mozilla.org/rust/">https://research.mozilla.org/rust/</a></p>
<p>rust-lang. (s. f.-a). Install Rust. Recuperado 26 de abril de 2020, de <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></p>
<p>rust-lang. (s. f.-b). Learn Rust. Recuperado 27 de marzo de 2020, de <a href="https://www.rust-lang.org/learn">https://www.rust-lang.org/learn</a></p>
<p>rust-lang. (s. f.-c). Production users. Recuperado 26 de abril de 2020, de <a href="https://www.rust-lang.org/production/users">https://www.rust-lang.org/production/users</a></p>
<p>Servo. (s. f.). Servo, the parallel browser engine. Recuperado 26 de abril de 2020, de <a href="https://servo.org/">https://servo.org/</a></p>
<p>Stack Overflow. (s. f.). Stack Overflow Developer Survey 2020. Recuperado 26 de abril de 2020, de <a href="https://insights.stackoverflow.com/survey/2020/">https://www.rust-lang.org/production/users</a>#technology-most-loved-dreaded-and-wanted-languages-loved</p>
]]></content>
        </item>
        
    </channel>
</rss>
